import { useState as y, useCallback as c, useEffect as E, useRef as b, useMemo as m } from "react";
function q() {
  const [a, u] = y(
    document.visibilityState === "visible"
  ), o = c(() => {
    u(document.visibilityState === "visible");
  }, []);
  return E(() => (document.addEventListener("visibilitychange", o), () => {
    document.removeEventListener("visibilitychange", o);
  }), [o]), a;
}
function l(a) {
  console.warn(`[react-use-wake-lock]: ${a}`);
}
function V(a) {
  const u = q(), [o, L] = y(!1), f = b(!1), d = b(!1), [r, g] = y(null), n = "wakeLock" in navigator, s = b(a), i = c((e, t) => {
    var h;
    ((h = s.current) == null ? void 0 : h.onError) != null && s.current.onError(e, t);
  }, []), v = c((e) => {
    var t;
    ((t = s.current) == null ? void 0 : t.onLock) != null && s.current.onLock(e);
  }, []), w = c((e) => {
    var t;
    ((t = s.current) == null ? void 0 : t.onRelease) != null && s.current.onRelease(e);
  }, []), k = c(async () => {
    if (!n) {
      l("WakeLock is not supported by the browser");
      return;
    }
    if (f.current === !0) {
      l("WakeLock request is in progress. noop");
      return;
    }
    if (r != null && r.released === !1) {
      l("Already have a lock. noop");
      return;
    }
    d.current = !1;
    try {
      f.current = !0;
      const e = await navigator.wakeLock.request("screen");
      e.addEventListener("release", () => {
        L(!1), w(e);
      }), g(e), L(!0), v(e);
    } catch (e) {
      e instanceof Error ? i(e, "request") : i(new Error("Unknown error type on request"), "request");
    } finally {
      f.current = !1;
    }
  }, [n, r, v, w, i]), p = c(async () => {
    if (!n) {
      l("WakeLock is not supported by the browser");
      return;
    }
    if (r == null) {
      l("Trying to release lock without having one: noop");
      return;
    }
    try {
      d.current = !0, await r.release();
    } catch (e) {
      e instanceof Error ? i(e, "release") : i(new Error("Unknown error type on release"), "release");
    }
  }, [n, r, i]);
  return E(() => {
    n && r != null && u && r.released && d.current !== !0 && k();
  }, [n, u, r, k]), m(
    () => ({
      isSupported: n,
      isLocked: o,
      request: k,
      release: p
    }),
    [o, n, p, k]
  );
}
export {
  V as default
};
